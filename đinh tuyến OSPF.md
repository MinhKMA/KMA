#Định tuyến OSPF##Tổng quanOSPF – Open Shortest Path First là một giao thức định tuyến link – state điển hình. Đây là một giao thức được sử dụng rộng rãi trong các mạng doanh nghiệp có kích thước lớn. Trong chương trình CCNA, đây cũng là một chủ đề chính được đề cập nhiều. Do đó, nắm vững những nguyên tắc hoạt động của OSPF sẽ giúp các bạn đang theo học chương trình CCNA hoàn thành tốt kỳ thi lấy chứng chỉ quốc tế CCNA cũng như đáp ứng tốt nhu cầu công việc trong thực tế.Một số đặc điểm chính của giao thức OSPF:- OSPF là một giao thức link – state điển hình. Mỗi router khi chạy giao thức sẽ gửi các trạng thái đường link của nó cho tất cả các router trong vùng (area). Sau một thời gian trao đổi, các router sẽ đồng nhất được bảng cơ sở dữ liệu trạng thái đường link (Link State Database – LSDB) với nhau, mỗi router đều có được “bản đồ mạng” của cả vùng. Từ đó mỗi router sẽ chạy giải thuật Dijkstra tính toán ra một cây đường đi ngắn nhất (Shortest Path Tree) và dựa vào cây này để xây dựng nên bảng định tuyến.- OSPF có AD = 110.- Metric của OSPF còn gọi là cost, được tính theo bandwidth trên cổng chạy OSPF.- OSPF chạy trực tiếp trên nền IP, có protocol – id là 89.- OSPF là một giao thức chuẩn quốc tế, được định nghĩa trong RFC – 2328.##Hoạt động của OSPF###Bầu chọn route idKhi router chạy OSPF thì phải có một giá trị duy nhất dùng để định danh cho router trong cộng đồng các router chạy OSPF. Giá trị này được gọi là Router – id.Router – id trên router chạy OSPF có định dạng của một địa chỉ IP. Mặc định, tiến trình OSPF trên mỗi router sẽ tự động bầu chọn giá trị router – id là địa chỉ IP cao nhất trong các interface đang active, ưu tiên cổng loopback.Để đổi lại router – id của tiến trình, phải thực hiện khởi động lại router hoặc gỡ bỏ tiến trình OSPF rồi cấu hình lại, khi đó tiến trình bầu chọn router – id sẽ được thực hiện lại với các interface đang hiện hữu trên router. Có một cách khác để thiết lập lại giá trị router – id là sử dụng câu lệnh “router-id” để thiết lập bằng tay giá trị này trên router:```Router (config) # router ospf 1`````Router (config-router) # router-id A.B.C.D``Bên cạnh đó, nếu tiến trình OSPF đã chạy và router – id đã được thiết lập trước đó, ta phải khởi động lại tiến trình OSPF thì mới áp dụng được giá trị router – id mới được chỉ ra trong câu lệnh “router – id”. Câu lệnh khởi động lại tiến trình OSPF:```Router (config) # clear ip ospf process``````Reset ALL OSPF proccess? [no]: yes```**node**: Nếu có 3 mạng kết nối với route là 192.168.10.6; 192.168.1.1; và một mạng loopback nào đó thì ta phải ưu tiên mạng loopback trước còn nếu không chọn mạng có địa chỉ ip cao hơn ###Thiết lập quan hệ láng giếng Bước tiếp theo, sau khi đã chọn xong router – id, router chạy OSPF sẽ gửi ra tất cả các cổng chạy OSPF một loại gói tin được gọi là gói tin hello. Gói tin này được gửi đến địa chỉ multicast dành riêng cho OSPF là 224.0.0.5, đến tất cả các router chạy OSPF khác trên cùng phân đoạn mạng. Mục đích của gói tin hello là giúp cho router tìm kiếm láng giềng, thiết lập và duy trì mối quan hệ này. Gói tin hello được gửi theo định kỳ mặc định 10s/lần.Có nhiều thông tin được hai router kết nối trực tiếp trao đổi với nhau qua gói tin hello. Trong các loại thông tin được trao đổi, có năm loại thông tin sau bắt buộc phải match với nhau trên hai router để chúng có thể thiết lập được quan hệ láng giềng với nhau:#### Area – id.####Hello timer và Dead timer.Hello timer là khoảng thời gian định kỳ gửi gói tin hello ra khỏi một cổng chạy OSPF. Khi một router nhận được hello từ láng giềng, nó sẽ khởi động Dead timer. Nếu sau khoảng thời gian được chỉ ra trong Dead timer mà router không nhận được gói tin hello từ láng giềng, nó sẽ coi như láng giềng này không còn và sẽ xóa mọi thông tin mà nó học được từ láng giềng. Ngược lại, cứ mỗi lần nhận được gói tin hello từ láng giềng, Dead timer lại được reset. Giá trị mặc định của hello – timer và dead – timer là 10s và 40s####Hai địa chỉ IP đấu nối phải cùng subnet (một vài trường hợp còn yêu cầu cùng cả subnet – mask).####Thỏa mãn các điều kiện xác thực.Trong trường hợp để tăng cường tính bảo mật của hoạt động trao đổi thông tin định tuyến, chúng ta thực hiện cài đặt các pasword trên hai router hai đầu đường link. Yêu cầu bắt buộc là hai password này phải khớp nhau ở hai đầu để hai router có thể thiết lập neighbor (tất nhiên!). Cấu hình xác thực sai có thể dẫn đến không thiết lập neighbor được giữa hai router từ đó dẫn đến không trao đổi được thông tin định tuyến.####Cùng bật hoặc cùng tắt cờ stub.####Trao đổi cơ sở dữ lieu#### Point - to - pointLoại link point – to – point điển hình là kết nối serial điểm – điểm chạy giao thức HDLC hoặc PPP nối giữa hai router. Đây là một giao thức 2 chiều, các route kết nối với nhau sẽ gửi toàn bộ cơ sở dữ lieu cho nhau.###Broadcast MultiaccessMôi trường Broadcast Multiaccess điển hình chính là môi trường Ethernet LAN<img src="http://i.imgur.com/HrgYanm.png">Ở đây chúng ta cần bần chọn ra router DR và router BDR. Giả sử R1 là route DR, R2 là route BDR. R1 đóng vai trò là route điều phối R2 là route dự phòng cho trường hợp R1 gặp sự cố. Về quan hệ giữa các cặp router lúc này, ta thấy như sau:- Các DROther không bao giờ trao đổi thông tin với nhau nên quan hệ giữa chúng mãi mãi chỉ dừng lại ở mức độ 2 – WAY. Thực hiện show bảng neighbor trên các router DROther sẽ thấy rằng các router này hiển thị tình trạng quan hệ với nhau là 2-WAY/DROther.- Các DROther có trao đổi dữ liệu với DR và BDR nên trong bảng neighbor của các router DROther, các router DR và BDR sẽ hiện ra với quan hệ dạng full: FULL/DR và FULL/BDR. Ngược lại, các router DR và BDR cũng thấy tình trạng quan hệ của các router DROther với chúng là FULL/DROther.Như vậy, router DR đóng một vai trò rất quan trọng trên môi trường Multiaccess: đó là router điều phối thông tin trên môi trường này. Vậy router nào sẽ được chọn làm DR? Ta có nguyên tắc bầu chọn DR và BDR cho một môi trường multi – access như sau:- Trên mỗi cổng đấu nối multi – access của mỗi router đều có một giá trị gọi là priority. Giá trị priority này nằm trong dải từ 0 đến 255 và được trao đổi giữa các router trong các gói tin hello. Router nào nắm giữ giá trị priority cao nhất sẽ được bầu chọn làm DR, priority cao nhì làm BDR, còn lại sẽ là DROther. Giá trị priority mặc định trên các cổng router là bằng 1. Lưu ý rằng nếu router mang giá trị priority bằng 0 sẽ không tham gia vào tiến trình bầu chọn DR và BDR, nó luôn luôn đảm nhận vai trò là DROther.- Trong trường hợp giá trị priority bằng nhau (ví dụ để mặc định bằng 1 hết, không cấu hình gì thêm), router nào có Router – id cao nhất sẽ làm DR, Router – id cao nhì sẽ làm BDR, còn lại làm DROther. Ta nói Router – id là tie – breaker của Priority.Có một số lưu ý cho việc bầu chọn DR và BDR như sau:- Nếu ta cấu hình một router nhận giá trị priority bằng 0, router này sẽ không tham gia vào tiến trình bầu chọn DR và BDR, nó luôn luôn là DROther. Chúng ta phải lưu ý điều này vì nếu chúng ta cấu hình cho tất cả các router đấu nối vào môi trường multi – access giá trị priority = 0 thì sẽ không có router nào chịu làm DR cho môi trường này! Lỗi này dẫn đến lỗ hổng trong việc trao đổi thông tin định tuyến.- Luật bầu chọn DR là non – preempt: khi một DR đã được bầu chọn xong, nếu router mới tham gia vào môi trường multi – access có priority hay router – id cao hơn router DR nó cũng không thể chiếm quyền của DR hiện tại. Chỉ khi nào DR hiện tại down, router khác mới có cơ hội tranh quyền DR.- Một router có thể đóng nhiều vai trò khác nhau trên nhiều cổng multi – acces khác nhau. Ví dụ: nó có thể là DR trên môi trường Multi – access đấu nối vào cổng F0/0 nhưng lại là DROther trên môi trường Multi – acces đấu nối vào cổng F0/1.- Chúng ta không được nhầm lẫn kết nối Ethernet nối 02 router là một kết nối point – to – point, kết nối này vẫn được xem là Multi – access. Trong trường hợp này, một router sẽ làm DR, một làm BDR, không có DROther 